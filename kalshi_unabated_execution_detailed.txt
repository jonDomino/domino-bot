KALSHI + UNABATED EXECUTION GUIDE (MINIMAL, END-TO-END)

This document describes the minimum information required to build a
working Telegram → Unabated → Kalshi execution script.

Anything not required for a functioning v1 is intentionally excluded.

==================================================
1. SYSTEM ROLES
==================================================

UNABATED
- Provides rotation numbers, teams, and start times
- Used only to resolve roto → game identity

KALSHI
- Execution venue
- Provides events, markets, orderbooks
- Executes trades

==================================================
2. UNABATED DATA ACCESS
==================================================

Unabated is accessed via a single snapshot endpoint.

There is no query-by-roto endpoint.
The snapshot must be pulled and filtered locally.

Relevant game structure:

{
  "eventStart": "2025-12-15T03:00:00Z",
  "eventTeams": [
    { "name": "New Jersey Devils", "rotationNumber": 2 },
    { "name": "Vancouver Canucks", "rotationNumber": 1 }
  ]
}

Rules:
- Rotation numbers are unique per league and date
- NHL teams do not play multiple games per day
- eventStart is authoritative and in UTC

==================================================
3. GAME DATE HANDLING
==================================================

All timestamps are handled in UTC.

The canonical game date is derived from eventStart
by converting to a YYYYMMDD string.

Midnight edge cases are ignored for v1.

==================================================
4. TEAM NORMALIZATION
==================================================

Team names must be normalized using a static CSV:

team_xref_nhl.csv

Example:
NHL,New Jersey Devils,NJ
NHL,NJ Devils,NJ
NHL,Vancouver Canucks,VAN

Rules:
- Case-insensitive exact match
- No heuristics
- If a team cannot be normalized, execution stops

==================================================
5. CANONICAL GAME KEY
==================================================

Used to join Unabated games to Kalshi events.

FORMAT:
{LEAGUE}_{YYYYMMDD}_{TEAM_A}_{TEAM_B}

Example:
NHL_20251214_NJ_VAN

Rules:
- Date derived from eventStart
- Teams sorted alphabetically
- Key must match exactly

==================================================
6. KALSHI EVENTS & MARKETS
==================================================

Fetch events:
GET /trade-api/v2/events
  ?series_ticker=KXNHLGAME
  &status=open
  &with_nested_markets=true

Example event:
event_ticker: KXNHLGAME-25DEC14VANNJ

Markets:
- <event_ticker>YES
- <event_ticker>N0

Match Kalshi events by reconstructing the canonical key.

If no match is found, execution stops.

==================================================
7. KALSHI ORDERBOOK
==================================================

GET /trade-api/v2/markets/{ticker}/orderbook

Response:
{
  orderbook: {
    yes: [[price, qty], ...],
    no:  [[price, qty], ...]
  }
}

Rules:
- Orderbook contains bids only
- Best bid is the last element
- No explicit ask side

==================================================
8. IMPLIED YES ASKS
==================================================

To buy YES contracts immediately, implied YES asks
must be computed from NO bids.

Formula:
YES_ASK = 100 - NO_BID

Execution planner must:
- Read orderbook["no"]
- Convert to implied YES asks
- Sort lowest price first

==================================================
9. TURN-IN INTERPRETATION
==================================================

Example:
NHL 2 NJ Devils -113 LIVE, 2.0

Interpretation:
- Buy YES on NJ Devils
- Max price: -113
- Budget: min(2.0 * 1000, 50) = $50

==================================================
10. PRICE CONVERSION
==================================================

American odds → implied probability:
p = -odds / (-odds + 100)

Kalshi price:
price_cents = round(p * 100)

This defines the MAX acceptable implied YES ask.

==================================================
11. FEES
==================================================

Use a single hardcoded constant:
TAKER_FEE_RATE = <defined in code>

Fee formula:
fee = ceil(rate * contracts * p * (1 - p) * 100) / 100

Rules:
- Always round UP
- Fees count toward the $50 cap
- Fees are aggregated across all fills

==================================================
12. EXECUTION PLANNING
==================================================

Goal:
Buy as many YES contracts as possible such that:
- implied YES ask <= price limit
- total cost + fees <= $50

Rules:
- No fractional contracts
- One order per price level
- Stop immediately when budget insufficient

==================================================
13. ORDER PLACEMENT
==================================================

POST /trade-api/v2/portfolio/orders

YES buy request body:
{
  "ticker": MARKET_TICKER,
  "type": "limit",
  "action": "buy",
  "side": "yes",
  "count": <integer>,
  "yes_price": <price_cents>,
  "client_order_id": <uuid>
}

Orders are placed sequentially.
Execution stops on rejection.

==================================================
14. TELEGRAM RESPONSE
==================================================

Send a single aggregate confirmation including:
- Contracts filled
- Average price
- Total spend
- Total fees

No emojis. Plain text.

==================================================
15. DESIGN CONSTRAINTS
==================================================

- Single script
- Single execution path
- Fail fast
- No retries
- No logging framework
- No dry-run
- No webhooks

This document contains all information required
to implement the system.
